<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Yahtzee Apex - Professional 3D Dice Game">
    <title>Yahtzee Apex | Gold Master v10</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700;800&display=swap');

        :root {
            --bg: #f8fafc;
            --surface: #ffffff;
            --surface-2: #f1f5f9;
            --text: #0f172a;
            --text-muted: #64748b;
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #e0e7ff;
            --accent: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #cbd5e1;
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.05);
            --tray-bg: #1e293b;
        }

        [data-theme="dark"] {
            --bg: #020617;
            --surface: #0f172a;
            --surface-2: #1e293b;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --border: #334155;
            --primary-light: rgba(99, 102, 241, 0.15);
            --tray-bg: #0b1120;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background: var(--bg);
            color: var(--text);
            transition: background 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-x: hidden;
            min-height: 100vh;
        }

        .app-shell {
            max-width: 1440px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 450px;
            gap: 32px;
            transition: all 0.5s;
        }

        body.scorecard-focused .app-shell {
            grid-template-columns: 1fr;
            max-width: 1000px;
        }

        body.scorecard-focused .main-stage { display: none !important; }

        header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .logo { font-weight: 800; font-size: 1.6rem; letter-spacing: -1px; display: flex; align-items: center; gap: 10px; }

        .toolbar { display: flex; gap: 12px; flex-wrap: wrap; }
        .btn {
            padding: 12px 20px;
            border-radius: 14px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        .btn:hover:not(:disabled) { background: var(--surface-2); transform: translateY(-1px); }
        .btn-primary { background: var(--primary); color: white; border: none; }
        .btn-icon { padding: 8px; width: 36px; height: 36px; border-radius: 50%; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

        .tray-viewport {
            width: 100%;
            aspect-ratio: 16 / 10;
            background: var(--tray-bg);
            border-radius: 28px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 30px 60px -12px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
        }

        .dice-controls {
            background: var(--surface);
            padding: 24px;
            border-radius: 28px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .rack { display: flex; gap: 16px; flex-wrap: wrap; justify-content: center; }
        .die-slot {
            width: 75px;
            height: 95px;
            background: var(--surface-2);
            border: 2px solid var(--border);
            border-radius: 18px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .die-slot.held {
            background: var(--primary);
            border-color: var(--primary);
            transform: translateY(-12px);
            color: white;
        }
        .die-slot .val { font-size: 2rem; font-weight: 800; }
        .die-slot .lbl { font-size: 0.65rem; font-weight: 800; text-transform: uppercase; opacity: 0.7; }

        .scorecard-container {
            background: var(--surface);
            border-radius: 28px;
            padding: 32px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 24px;
            overflow: hidden;
        }

        .score-scroll {
            overflow-x: auto;
            margin: 0 -10px;
            padding: 10px;
            scroll-behavior: smooth;
            /* Hide scrollbar for cleaner look */
            scrollbar-width: none;
        }
        .score-scroll::-webkit-scrollbar { display: none; }

        /* --- TABLE STYLES --- */
        table { 
            width: 100%; 
            border-collapse: separate; 
            border-spacing: 0; 
        }
        
        tr:nth-child(even) td, tr:nth-child(even) th { background: rgba(0,0,0,0.02); }
        [data-theme="dark"] tr:nth-child(even) td, 
        [data-theme="dark"] tr:nth-child(even) th { background: rgba(255,255,255,0.03); }

        th, td {
            padding: 0; 
            height: 54px;
            border-bottom: 1px solid var(--border);
            min-width: 130px;
            text-align: center;
            vertical-align: middle;
        }
        
        th:first-child, td:first-child {
            text-align: left;
            position: sticky;
            left: 0;
            background: var(--surface);
            z-index: 5;
            width: 160px;
            font-size: 0.9rem;
            border-right: 2px solid var(--border);
            padding-left: 12px;
        }
        tr:nth-child(even) th:first-child, tr:nth-child(even) td:first-child { background: var(--surface-2); }
        [data-theme="dark"] tr:nth-child(even) th:first-child, 
        [data-theme="dark"] tr:nth-child(even) td:first-child { background: #151e2e; }

        .player-header {
            position: relative;
            cursor: grab;
            padding: 10px !important;
        }
        .player-header:active { cursor: grabbing; }
        .player-header .remove-btn {
            position: absolute; top: 4px; right: 4px; font-size: 10px;
            color: var(--danger); cursor: pointer; opacity: 0;
            transition: opacity 0.2s; padding: 4px;
        }
        .player-header:hover .remove-btn { opacity: 1; }

        .active-turn-col {
            background: var(--primary-light) !important;
            box-shadow: inset 0 0 0 1px var(--primary); 
        }
        .active-badge {
            font-size: 0.6rem; background: var(--primary); color: white;
            padding: 2px 6px; border-radius: 4px; text-transform: uppercase;
            position: absolute; top: -10px; left: 50%; transform: translateX(-50%);
        }

        .cell-wrapper {
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; position: relative;
        }
        
        .score-val { font-weight: 800; font-size: 1.1rem; }
        .score-hint {
            font-size: 0.9rem; font-weight: 700; padding: 4px 12px;
            border-radius: 20px; transition: all 0.2s;
            background: rgba(0,0,0,0.05); color: var(--text-muted);
        }
        [data-theme="dark"] .score-hint { background: rgba(255,255,255,0.1); }
        
        .score-hint.good { background: rgba(16, 185, 129, 0.15); color: var(--accent); }
        .score-hint.bad { background: rgba(239, 68, 68, 0.1); color: var(--danger); opacity: 0.8; }
        
        .cell-wrapper:hover .score-hint { transform: scale(1.1); }
        .cell-wrapper.locked { cursor: default; }
        .cell-wrapper.locked:hover { background: none; }

        .inline-score-input {
            width: 100%; height: 100%;
            background: transparent; 
            border: none; outline: none;
            text-align: center; 
            font-family: inherit; font-weight: 800; font-size: 1.1rem;
            color: var(--text); padding: 0; margin: 0;
            border-bottom: 2px solid transparent;
            transition: border-color 0.2s;
        }
        .inline-score-input:focus { border-bottom-color: var(--primary); }

        .player-name-input {
            width: 100%; background: transparent; border: none; color: var(--text);
            font-weight: 800; text-align: center; font-family: inherit; font-size: 1rem; cursor: pointer;
        }
        .player-name-input:focus { outline: none; text-decoration: underline; }
        ::selection { background: var(--primary-light); color: var(--primary); }

        .tooltip-trigger { cursor: help; display: inline-flex; align-items: center; gap: 8px; }
        .info-icon {
            font-size: 0.7rem; color: var(--text-muted); border: 1px solid var(--border);
            border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;
        }
        .tooltip-popover {
            position: absolute; background: #1e293b; color: white; padding: 8px 12px;
            border-radius: 8px; font-size: 0.8rem; z-index: 100; pointer-events: none;
            opacity: 0; transition: opacity 0.2s; width: max-content; max-width: 200px;
            left: 100%; top: 50%; transform: translateY(-50%); margin-left: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .tooltip-trigger:hover .tooltip-popover { opacity: 1; }

        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px);
            display: none; align-items: center; justify-content: center; z-index: 2000;
        }
        .modal-overlay.active { display: flex; }
        
        .close-modal-btn {
            position: absolute; top: 15px; right: 15px;
            background: var(--surface-2); border: none;
            width: 32px; height: 32px; border-radius: 50%;
            font-size: 1.2rem; cursor: pointer; color: var(--text);
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .close-modal-btn:hover { background: var(--danger); color: white; }

        @media (max-width: 1024px) {
            .app-shell { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

<div class="app-shell">
    <header>
        <div class="logo"><span>üé≤</span> YAHTZEE APEX</div>
        <div class="toolbar">
            <button class="btn" onclick="game.toggleFocusMode()" id="focusBtn">üìã Scorecard Mode</button>
            <button class="btn" onclick="game.undo()" id="undoBtn" disabled>‚Ü© Undo</button>
            <button class="btn" onclick="game.toggleTheme()">üåì Theme</button>
            <button class="btn" style="color: var(--danger)" onclick="game.confirmReset()">‚ôª New Game</button>
        </div>
    </header>

    <main class="main-stage">
        <div class="tray-viewport" id="trayViewport">
            <div id="canvas-3d" style="width: 100%; height: 100%;"></div>
        </div>

        <div class="dice-controls">
            <div style="display: flex; justify-content: space-between; width: 100%; color: var(--text-muted); font-weight: 800; font-size: 0.8rem;">
                <span id="rollStatus">ROLL 0 / 3</span>
                <span onclick="game.clearHolds()" style="cursor: pointer; color: var(--primary)">CLEAR KEEPERS</span>
            </div>
            <div class="rack" id="diceRack"></div>
            <button class="btn btn-primary" id="rollBtn" onclick="game.roll()"
                style="width: 100%; max-width: 400px; height: 65px; font-size: 1.3rem; letter-spacing: 2px; justify-content: center;">
                ROLL DICE
            </button>
        </div>
    </main>

    <aside class="scorecard-container">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="display:flex; align-items: center; gap: 10px;">
                <button class="btn btn-icon" onclick="game.manualPrevTurn()" title="Previous Player">‚óÄ</button>
                <div style="text-align:center; min-width: 100px;">
                    <div style="font-size: 0.7rem; font-weight: 800; color: var(--text-muted); text-transform: uppercase;">Active Turn</div>
                    <h2 id="activePlayerDisplay" style="font-size: 1.2rem;">Player 1</h2>
                </div>
                <button class="btn btn-icon" onclick="game.manualNextTurn()" title="Next Player">‚ñ∂</button>
            </div>
            <button class="btn btn-primary" onclick="game.addPlayer()" style="padding: 8px 16px; font-size: 0.8rem;">+ Player</button>
        </div>

        <div class="score-scroll" id="scoreScroll">
            <table id="scoreTable">
                <thead><tr id="playerHeaderRow"><th>Category</th></tr></thead>
                <tbody id="scoreTableBody"></tbody>
            </table>
        </div>
    </aside>
</div>

<div class="modal-overlay" id="gameOverModal">
    <div style="background: var(--surface); padding: 40px; border-radius: 28px; width: 90%; max-width: 450px; text-align: center; position: relative;">
        <button class="close-modal-btn" onclick="game.closeModal()">√ó</button>
        <h2>üèÜ Game Complete!</h2>
        <div id="finalScores" style="margin: 24px 0;"></div>
        <button class="btn btn-primary" onclick="location.reload()" style="width: 100%; justify-content: center;">Play Again</button>
    </div>
</div>

<div class="modal-overlay" id="confirmModal">
    <div style="background: var(--surface); padding: 40px; border-radius: 28px; width: 90%; max-width: 400px; text-align: center;">
        <h2 id="confirmTitle" style="margin-bottom: 12px;">Are you sure?</h2>
        <p id="confirmText" style="color: var(--text-muted); margin-bottom: 24px;">This action cannot be undone.</p>
        <div style="display: flex; gap: 12px; justify-content: center;">
            <button class="btn" onclick="document.getElementById('confirmModal').classList.remove('active')">Cancel</button>
            <button class="btn btn-primary" id="confirmActionBtn" style="background: var(--danger);">Confirm</button>
        </div>
    </div>
</div>

<script>
// --- Physics & Graphics Engine ---
    class DiceEngine {
        constructor(containerId, onSettle) {
            this.container = document.getElementById(containerId);
            this.onSettle = onSettle;
            this.dice = [];
            this.isRolling = false;
            this.targetPositions = new Array(5).fill(null);
            this.init();
        }

        init() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(35, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
            this.camera.position.set(0, 16, 4); 
            this.camera.lookAt(0, -2, -0.5);

            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.container.appendChild(this.renderer.domElement);

            this.scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const sun = new THREE.DirectionalLight(0xffffff, 0.6);
            sun.position.set(5, 15, 5);
            sun.castShadow = true;
            this.scene.add(sun);

            this.world = new CANNON.World();
            this.world.gravity.set(0, -45, 0); 

            const groundMat = new CANNON.Material();
            const diceMat = new CANNON.Material();
            this.world.addContactMaterial(new CANNON.ContactMaterial(groundMat, diceMat, { friction: 0.8, restitution: 0.1 }));

            const createBox = (w, h, d, x, y, z) => {
                const body = new CANNON.Body({ mass: 0, material: groundMat });
                body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)));
                body.position.set(x, y, z);
                this.world.addBody(body);
            };

            createBox(30, 1, 30, 0, -0.5, 0); 
            createBox(30, 10, 1, 0, 5, -6.5);  
            createBox(30, 10, 1, 0, 5, 5.0);   
            createBox(1, 10, 30, -8.5, 5, 0);  
            createBox(1, 10, 30, 8.5, 5, 0);   

            this.createDice(diceMat);
            this.animate();
        }

        createDice(material) {
            const geo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const mats = this.getDiceTextures();
            for(let i=0; i<5; i++) {
                const mesh = new THREE.Mesh(geo, mats);
                mesh.castShadow = true;
                const body = new CANNON.Body({
                    mass: 2.0, material: material,
                    shape: new CANNON.Box(new CANNON.Vec3(0.6, 0.6, 0.6)),
                    linearDamping: 0.3, angularDamping: 0.3
                });
                body.position.set((i-2)*2, 1, 0);
                this.dice.push({mesh, body, val: 1});
                this.scene.add(mesh);
                this.world.addBody(body);
            }
        }

        getDiceTextures() {
            return [1,6,2,5,3,4].map(n => {
                const c = document.createElement('canvas'); c.width=128; c.height=128;
                const x = c.getContext('2d'); 
                x.fillStyle='#ffffff'; x.fillRect(0,0,128,128);
                x.strokeStyle = '#e2e8f0'; x.lineWidth = 6; x.strokeRect(0,0,128,128);
                x.fillStyle='#1e293b';
                const d = (u,v) => { x.beginPath(); x.arc(u,v,14,0,Math.PI*2); x.fill(); };
                if(n%2) d(64,64);
                if(n>1) { d(34,34); d(94,94); }
                if(n>3) { d(94,34); d(34,94); }
                if(n==6) { d(34,64); d(94,64); }
                return new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(c) });
            });
        }

        setOrientation(body, val) {
            const q = new CANNON.Quaternion();
            switch(val) {
                case 1: q.setFromAxisAngle(new CANNON.Vec3(0,0,1), Math.PI/2); break; 
                case 6: q.setFromAxisAngle(new CANNON.Vec3(0,0,1), -Math.PI/2); break; 
                case 2: q.set(0,0,0,1); break; 
                case 5: q.setFromAxisAngle(new CANNON.Vec3(1,0,0), Math.PI); break; 
                case 3: q.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2); break; 
                case 4: q.setFromAxisAngle(new CANNON.Vec3(1,0,0), Math.PI/2); break; 
            }
            body.quaternion.copy(q);
            body.angularVelocity.set(0,0,0);
        }

        setHeldStatus(i, isHeld, val) {
            const d = this.dice[i];
            if(isHeld) {
                d.body.type = CANNON.Body.KINEMATIC;
                this.targetPositions[i] = new CANNON.Vec3((i - 2) * 1.7, 0.6, 3.8);
                d.val = val; 
                this.setOrientation(d.body, val);
            } else {
                d.body.type = CANNON.Body.DYNAMIC;
                this.targetPositions[i] = null;
                d.body.wakeUp();
            }
        }

        roll(held) {
            this.isRolling = true;
            this.dice.forEach((d, i) => {
                if (held.includes(i)) {
                    d.body.type = CANNON.Body.KINEMATIC;
                    this.targetPositions[i] = new CANNON.Vec3((i - 2) * 1.7, 0.6, 3.8);
                    this.setOrientation(d.body, d.val);
                } else {
                    d.body.type = CANNON.Body.DYNAMIC;
                    this.targetPositions[i] = null;
                    d.body.position.set(Math.random() * 6 - 3, 8 + i, -5); 
                    d.body.velocity.set(Math.random() * 10 - 5, 2, 14 + Math.random() * 5); 
                    d.body.angularVelocity.set(Math.random() * 25, Math.random() * 25, Math.random() * 25);
                }
            });
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            this.world.step(1/60);
            let moving = false;
            this.dice.forEach((d, i) => {
                if (this.targetPositions[i]) {
                    d.body.position.lerp(this.targetPositions[i], 0.25, d.body.position);
                    d.body.velocity.set(0,0,0);
                    d.body.angularVelocity.set(0,0,0);
                }
                d.mesh.position.copy(d.body.position);
                d.mesh.quaternion.copy(d.body.quaternion);
                if (d.body.type === CANNON.Body.DYNAMIC && d.body.velocity.length() > 0.2) moving = true;
            });
            if (this.isRolling && !moving) {
                this.isRolling = false;
                this.onSettle(this.getValues());
            }
            this.renderer.render(this.scene, this.camera);
        }

        getValues() {
            const vectors = [{v:1, d:new THREE.Vector3(1,0,0)}, {v:6, d:new THREE.Vector3(-1,0,0)}, {v:2, d:new THREE.Vector3(0,1,0)}, {v:5, d:new THREE.Vector3(0,-1,0)}, {v:3, d:new THREE.Vector3(0,0,1)}, {v:4, d:new THREE.Vector3(0,0,-1)}];
            return this.dice.map(d => {
                let max = -1, val = 1;
                vectors.forEach(u => {
                    const w = u.d.clone().applyQuaternion(d.mesh.quaternion);
                    if(w.y > max) { max = w.y; val = u.v; }
                });
                d.val = val;
                return val;
            });
        }

        resize() {
            this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        }
    }

    // --- Game Logic ---
    const RULES = [
        { id: '1s', name: 'Ones', max: 5, tip: 'Sum of Ones (Max 5)' },
        { id: '2s', name: 'Twos', max: 10, tip: 'Sum of Twos (Max 10)' },
        { id: '3s', name: 'Threes', max: 15, tip: 'Sum of Threes (Max 15)' },
        { id: '4s', name: 'Fours', max: 20, tip: 'Sum of Fours (Max 20)' },
        { id: '5s', name: 'Fives', max: 25, tip: 'Sum of Fives (Max 25)' },
        { id: '6s', name: 'Sixes', max: 30, tip: 'Sum of Sixes (Max 30)' },
        { id: 'uSum', name: 'Upper Total', calc: true },
        { id: 'bonus', name: 'Bonus', calc: true, tip: '+35 pts if Upper > 63' },
        { id: '3k', name: '3 of a Kind', max: 30, tip: 'Sum dice if 3 match' },
        { id: '4k', name: '4 of a Kind', max: 30, tip: 'Sum dice if 4 match' },
        { id: 'fh', name: 'Full House', fixed: 25, tip: '3 of a kind + Pair (25 pts)' },
        { id: 'ss', name: 'Sm. Straight', fixed: 30, tip: 'Sequence of 4 (30 pts)' },
        { id: 'ls', name: 'Lg. Straight', fixed: 40, tip: 'Sequence of 5 (40 pts)' },
        { id: 'yz', name: 'Yahtzee', fixed: 50, tip: '5 of a Kind (50 pts)' },
        { id: 'yb', name: 'Yahtzee Bonus', check: true, tip: '100pts per extra Yahtzee' },
        { id: 'ch', name: 'Chance', max: 30, tip: 'Sum of all dice' },
        { id: 'grand', name: 'Grand Total', calc: true }
    ];

    const PLAYABLE_CATS = ['1s','2s','3s','4s','5s','6s','3k','4k','fh','ss','ls','yz','ch'];

    class YahtzeeElite {
        constructor() {
            this.players = [{ name: 'Player 1', scores: {}, bonusCount: 0 }];
            this.turnIdx = 0;
            this.rolls = 0;
            this.held = [];
            this.values = [1, 1, 1, 1, 1];
            this.history = [];
            this.engine = new DiceEngine('canvas-3d', (v) => this.onSettle(v));
            this.initUI();
            this.render();
            setTimeout(() => this.engine.resize(), 100);
        }

        initUI() {
            const rack = document.getElementById('diceRack');
            for (let i = 0; i < 5; i++) {
                const slot = document.createElement('div');
                slot.className = 'die-slot';
                slot.id = `slot-${i}`;
                slot.onclick = () => this.toggleHold(i);
                slot.innerHTML = `<span class="val" id="dv-${i}">-</span><span class="lbl" id="dl-${i}">KEEP</span>`;
                rack.appendChild(slot);
            }
        }

        roll() {
            if (this.rolls >= 3 || this.engine.isRolling) return;
            this.rolls++;
            this.engine.roll(this.held);
            document.getElementById('rollBtn').disabled = true;
            document.getElementById('rollStatus').textContent = `ROLL ${this.rolls} / 3`;
        }

        onSettle(vals) {
            vals.forEach((v, i) => {
                if (!this.held.includes(i)) this.values[i] = v;
                document.getElementById(`dv-${i}`).textContent = this.values[i];
            });
            document.getElementById('rollBtn').disabled = (this.rolls >= 3);
            this.render();
        }

        toggleHold(i) {
            if (this.rolls === 0 || this.engine.isRolling) return;
            const idx = this.held.indexOf(i);
            if (idx > -1) this.held.splice(idx, 1);
            else this.held.push(i);

            const isHeld = this.held.includes(i);
            this.engine.setHeldStatus(i, isHeld, this.values[i]); 
            const slot = document.getElementById(`slot-${i}`);
            slot.classList.toggle('held', isHeld);
            document.getElementById(`dl-${i}`).textContent = isHeld ? 'KEEPER' : 'KEEP';
        }

        clearHolds() {
            this.held.forEach(i => this.engine.setHeldStatus(i, false, this.values[i]));
            this.held = [];
            document.querySelectorAll('.die-slot').forEach(s => {
                s.classList.remove('held');
                s.querySelector('.lbl').textContent = 'KEEP';
            });
        }

        // Handle Clicking the Yahtzee Bonus Box
        toggleBonus(pIdx) {
            if (pIdx !== this.turnIdx) return;
            const isYahtzee = new Set(this.values).size === 1;
            if (!isYahtzee) {
                alert("Invalid Bonus: Dice must show a Yahtzee.");
                return;
            }
            const p = this.players[pIdx];
            if (p.scores['yz'] !== 50) {
                alert("Invalid Bonus: You must have a scored Yahtzee (50) first.");
                return;
            }

            p.bonusCount = (p.bonusCount || 0) + 1;
            if (p.bonusCount > 13) p.bonusCount = 13; 
            this.render();
        }

        score(pIdx, catId, manualVal = null) {
            // Manual Scorecard Mode
            if (manualVal !== null) {
                if(manualVal === "") delete this.players[pIdx].scores[catId];
                else {
                    let val = parseInt(manualVal);
                    if(isNaN(val)) val = 0;

                    // STRICT VALIDATION
                    const rule = RULES.find(r => r.id === catId);
                    if (rule) {
                        // Cap Max Values (e.g. Ones max 5)
                        if (rule.max && val > rule.max) val = rule.max;
                        // Fixed Values (e.g. Full House is 25 or 0)
                        if (rule.fixed && val > 0) val = rule.fixed;
                    }

                    this.players[pIdx].scores[catId] = val;
                }
                this.render();
                return;
            }

            // Game Mode Logic
            if (pIdx !== this.turnIdx || this.rolls === 0 || this.players[pIdx].scores[catId] !== undefined) return;

            // SAVE HISTORY
            this.history.push(JSON.stringify({
                players: this.players,
                turnIdx: this.turnIdx,
                rolls: this.rolls,
                values: [...this.values],
                held: [...this.held]
            }));
            
            const p = this.players[pIdx];
            const isYahtzee = new Set(this.values).size === 1;
            const dieVal = this.values[0];

            if (isYahtzee && p.scores['yz'] !== undefined) {
                if (p.scores['yz'] === 50) {
                    p.bonusCount = (p.bonusCount || 0) + 1;
                }
                const upperKey = ['1s','2s','3s','4s','5s','6s'][dieVal - 1];
                const isUpperOpen = p.scores[upperKey] === undefined;
                
                if (isUpperOpen) {
                    if (catId !== upperKey) {
                        alert(`Joker Rule: You must fill the ${upperKey} box!`);
                        this.history.pop();
                        return;
                    }
                } else {
                    const lowerKeys = ['3k','4k','fh','ss','ls','yz','ch'];
                    const isLower = lowerKeys.includes(catId);
                    if (isLower) {
                        if(catId === 'fh') this.players[pIdx].scores[catId] = 25;
                        else if(catId === 'ss') this.players[pIdx].scores[catId] = 30;
                        else if(catId === 'ls') this.players[pIdx].scores[catId] = 40;
                        else this.players[pIdx].scores[catId] = this.calc(catId, this.values);
                        this.finishTurn();
                        return;
                    } 
                }
            }

            this.players[pIdx].scores[catId] = this.calc(catId, this.values);
            this.finishTurn();
        }

        finishTurn() {
            if(this.checkGameOver()) {
                this.render();
                this.showGameOver();
            } else {
                this.nextTurn();
            }
        }

        checkGameOver() {
            return this.players.every(p => 
                PLAYABLE_CATS.every(cat => p.scores[cat] !== undefined)
            );
        }

        showGameOver() {
            const finalDiv = document.getElementById('finalScores');
            let html = '<div style="display:flex; flex-direction:column; gap:10px;">';
            const sortedPlayers = [...this.players].sort((a,b) => 
                this.getCalc(this.players.indexOf(b), 'grand') - this.getCalc(this.players.indexOf(a), 'grand')
            );
            sortedPlayers.forEach((p, i) => {
                const idx = this.players.indexOf(p);
                const score = this.getCalc(idx, 'grand');
                html += `
                    <div style="background:var(--surface-2); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; border: 2px solid ${i===0 ? 'var(--warning)' : 'var(--border)'}">
                        <div style="font-weight:700;">${i===0 ? 'üëë ' : ''}${p.name}</div>
                        <div style="font-size:1.5rem; font-weight:800; color:${i===0 ? 'var(--warning)' : 'var(--text)'}">${score}</div>
                    </div>
                `;
            });
            html += '</div>';
            finalDiv.innerHTML = html;
            document.getElementById('gameOverModal').classList.add('active');
        }

        closeModal() {
            document.getElementById('gameOverModal').classList.remove('active');
        }

        calc(id, dice) {
            const sum = dice.reduce((a, b) => a + b, 0);
            const counts = {}; dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
            const u = [...new Set(dice)].sort().join('');
            switch(id) {
                case '1s': return (counts[1] || 0);
                case '2s': return (counts[2] || 0) * 2;
                case '3s': return (counts[3] || 0) * 3;
                case '4s': return (counts[4] || 0) * 4;
                case '5s': return (counts[5] || 0) * 5;
                case '6s': return (counts[6] || 0) * 6;
                case '3k': return Object.values(counts).some(c => c >= 3) ? sum : 0;
                case '4k': return Object.values(counts).some(c => c >= 4) ? sum : 0;
                case 'fh': return Object.values(counts).includes(3) && Object.values(counts).includes(2) ? 25 : 0;
                case 'ss': return /1234|2345|3456/.test(u) ? 30 : 0;
                case 'ls': return /12345|23456/.test(u) ? 40 : 0;
                case 'yz': return Object.values(counts).includes(5) ? 50 : 0;
                case 'ch': return sum;
                case 'yb': return 0;
                default: return 0;
            }
        }

        getHintColor(id, val) {
            const rule = RULES.find(r => r.id === id);
            if (!rule || !rule.max || rule.check) return '';
            const ratio = val / rule.max;
            if (ratio >= 0.7) return 'good';
            if (val === 0) return 'bad';
            return 'avg';
        }

        manualNextTurn() { this.turnIdx = (this.turnIdx + 1) % this.players.length; this.render(); setTimeout(() => this.syncSnap(), 50); }
        manualPrevTurn() { this.turnIdx = (this.turnIdx - 1 + this.players.length) % this.players.length; this.render(); setTimeout(() => this.syncSnap(), 50); }
        nextTurn() {
            this.rolls = 0;
            this.clearHolds();
            this.turnIdx = (this.turnIdx + 1) % this.players.length;
            document.querySelectorAll('.val').forEach(v => v.textContent = '-');
            document.getElementById('rollStatus').textContent = `ROLL 0 / 3`;
            document.getElementById('rollBtn').disabled = false;
            this.render();
            setTimeout(() => this.syncSnap(), 50);
        }

        syncSnap() {
            const activeCol = document.querySelector('.active-turn-col');
            if (activeCol) {
                // FORCE CENTER ALIGNMENT
                activeCol.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
            }
        }

        renamePlayer(idx, name) { this.players[idx].name = name; }
        addPlayer() { if (this.players.length < 8) { this.players.push({ name: `Player ${this.players.length + 1}`, scores: {}, bonusCount: 0 }); this.render(); setTimeout(() => this.syncSnap(), 50); } }
        confirmReset() { document.getElementById('confirmTitle').textContent = "New Game?"; document.getElementById('confirmText').textContent = "All scores will be lost."; document.getElementById('confirmActionBtn').onclick = () => location.reload(); document.getElementById('confirmModal').classList.add('active'); }
        confirmRemovePlayer(idx) { document.getElementById('confirmTitle').textContent = `Remove ${this.players[idx].name}?`; document.getElementById('confirmText').textContent = "Their scores will be deleted."; document.getElementById('confirmActionBtn').onclick = () => { this.removePlayer(idx); document.getElementById('confirmModal').classList.remove('active'); }; document.getElementById('confirmModal').classList.add('active'); }
        removePlayer(idx) { if(this.players.length > 1) { this.players.splice(idx, 1); if(this.turnIdx >= this.players.length) this.turnIdx = this.players.length - 1; this.render(); setTimeout(() => this.syncSnap(), 50); } }
        dragStart(e, idx) { this.dragSrcIdx = idx; e.dataTransfer.effectAllowed = 'move'; }
        dragDrop(e, idx) {
            if(this.dragSrcIdx === idx) return;
            const item = this.players[this.dragSrcIdx];
            this.players.splice(this.dragSrcIdx, 1);
            this.players.splice(idx, 0, item);
            if(this.turnIdx === this.dragSrcIdx) this.turnIdx = idx;
            else if(this.turnIdx > this.dragSrcIdx && this.turnIdx <= idx) this.turnIdx--;
            else if(this.turnIdx < this.dragSrcIdx && this.turnIdx >= idx) this.turnIdx++;
            this.render();
            setTimeout(() => this.syncSnap(), 50);
        }
        
        undo() {
            if (this.history.length === 0) return;
            
            const state = JSON.parse(this.history.pop());
            this.players = state.players;
            this.turnIdx = state.turnIdx;
            this.rolls = state.rolls;
            this.values = state.values;
            this.held = state.held;
            
            document.getElementById('rollStatus').textContent = `ROLL ${this.rolls} / 3`;
            document.getElementById('rollBtn').disabled = (this.rolls >= 3);
            
            this.values.forEach((v, i) => {
                 document.getElementById(`dv-${i}`).textContent = v;
                 this.engine.setHeldStatus(i, this.held.includes(i), v);
            });
            
            for(let i=0; i<5; i++) {
                 const slot = document.getElementById(`slot-${i}`);
                 const isHeld = this.held.includes(i);
                 slot.classList.toggle('held', isHeld);
                 document.getElementById(`dl-${i}`).textContent = isHeld ? 'KEEPER' : 'KEEP';
            }

            this.render();
            setTimeout(() => this.syncSnap(), 50);
        }

        toggleFocusMode() { document.body.classList.toggle('scorecard-focused'); const isFocus = document.body.classList.contains('scorecard-focused'); document.getElementById('focusBtn').textContent = isFocus ? 'üéÆ Game Mode' : 'üìã Scorecard Mode'; if(!isFocus) setTimeout(() => this.engine.resize(), 100); this.render(); setTimeout(() => this.syncSnap(), 50); }
        toggleTheme() { document.body.dataset.theme = document.body.dataset.theme === 'dark' ? 'light' : 'dark'; }

        render() {
            const isFocus = document.body.classList.contains('scorecard-focused');
            const head = document.getElementById('playerHeaderRow');
            
            // Render Headers
            head.innerHTML = '<th>Category</th>' + this.players.map((p, i) => {
                const isActive = i === this.turnIdx;
                return `
                <th class="player-header ${isActive ? 'active-turn-col' : ''}" 
                    draggable="true" ondragstart="game.dragStart(event, ${i})" ondragover="event.preventDefault()" ondrop="game.dragDrop(event, ${i})">
                    ${isActive ? '<span class="active-badge">Active</span>' : ''}
                    <span class="remove-btn" onclick="game.confirmRemovePlayer(${i})">‚úï</span>
                    <input class="player-name-input" type="text" value="${p.name}" onfocus="this.select()" oninput="game.renamePlayer(${i}, this.value)">
                </th>`;
            }).join('');

            const body = document.getElementById('scoreTableBody');
            body.innerHTML = '';
            
            // Render Rows
            RULES.forEach(r => {
                const tr = document.createElement('tr');
                let html = `<td class="tooltip-trigger">${r.name} ${r.tip ? `<span class="info-icon">?</span><div class="tooltip-popover">${r.tip}</div>` : ''}</td>`;
                
                this.players.forEach((p, pi) => {
                    const score = p.scores[r.id];
                    const isActive = (pi === this.turnIdx);
                    const cellClass = isActive ? 'active-turn-col' : '';
                    let content = '';

                    if (r.id === 'yb') {
                         // Yahtzee Bonus: Click to toggle count
                         let checks = '';
                         if(p.bonusCount > 0) {
                             checks = '‚úì' + (p.bonusCount > 1 ? `x${p.bonusCount}` : '');
                         }
                         // Always clickable to toggle count
                         content = `<div class="cell-wrapper" onclick="game.toggleBonus(${pi})" style="color: var(--accent); font-weight: 800; font-size: 1.1rem; cursor: pointer;">${checks}</div>`;
                    }
                    else if (r.calc) { 
                        content = `<div class="cell-wrapper" style="font-weight: 800; color: var(--primary)">${this.getCalc(pi, r.id)}</div>`; 
                    } else {
                        if (isFocus) { 
                            // Manual Input Mode
                            content = `<input class="inline-score-input" type="number" value="${score ?? ''}" min="0" max="${r.max || ''}" placeholder="-" onchange="game.score(${pi}, '${r.id}', this.value)">`; 
                        } else {
                            // Game Mode
                            const val = this.calc(r.id, this.values);
                            const hintType = this.getHintColor(r.id, val);
                            
                            if (isActive && this.rolls > 0 && score === undefined) {
                                content = `<div class="cell-wrapper" onclick="game.score(${pi}, '${r.id}')"><span class="score-hint ${hintType}">${val}</span></div>`;
                            } else {
                                content = `<div class="cell-wrapper ${score !== undefined ? 'locked' : ''}" onclick="game.score(${pi}, '${r.id}')"><span class="score-val">${score ?? ''}</span></div>`;
                            }
                        }
                    }
                    html += `<td class="${cellClass}">${content}</td>`;
                });
                tr.innerHTML = html; body.appendChild(tr);
            });
            document.getElementById('activePlayerDisplay').textContent = this.players[this.turnIdx].name;
            document.getElementById('undoBtn').disabled = (this.history.length === 0);
        }

        getCalc(pi, id) {
            const p = this.players[pi];
            const u = ['1s','2s','3s','4s','5s','6s'].reduce((a,c) => a + (p.scores[c]||0), 0);
            if (id === 'uSum') return u;
            if (id === 'bonus') return u >= 63 ? 35 : 0;
            const l = ['3k','4k','fh','ss','ls','yz','ch'].reduce((a,c) => a + (p.scores[c]||0), 0);
            const bonusPts = (p.bonusCount || 0) * 100;
            if (id === 'grand') return u + (u >= 63 ? 35 : 0) + l + bonusPts;
        }
    }

    const game = new YahtzeeElite();
    window.addEventListener('resize', () => game.engine.resize());
</script>

</body>
</html>
