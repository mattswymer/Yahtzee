<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yahtzee Elite - Premium Edition</title>
    <!-- Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');

        :root {
            --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --surface: #ffffff;
            --text: #2d3748;
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #48bb78;
            --danger: #f56565;
            --border: #e2e8f0;
            --shadow: rgba(0,0,0,0.1);
            --tray-bg: linear-gradient(145deg, #2d3748, #1a202c);
            
            /* Player Colors */
            --c1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --c2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --c3: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --c4: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            --c5: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --c6: linear-gradient(135deg, #30cfd0 0%, #330867 100%);
            --c7: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            --c8: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }

        [data-theme="dark"] {
            --bg: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            --surface: #2d3748;
            --text: #e2e8f0;
            --border: #4a5568;
            --shadow: rgba(0,0,0,0.3);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            font-family: 'Fredoka', 'Inter', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            max-width: 1400px;
            margin: 0 auto 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 12px;
            border: none;
            background: white;
            color: var(--text);
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px var(--shadow);
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: white; padding: 16px 48px; font-size: 18px; }
        .btn-danger { background: linear-gradient(135deg, #f56565 0%, #c53030 100%); color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        /* Physics Tray */
        .tray-container {
            max-width: 800px;
            margin: 0 auto 30px;
            background: white;
            border-radius: 24px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
        }

        #tray {
            width: 100%;
            height: 400px;
            background: var(--tray-bg);
            border-radius: 16px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 10px 40px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Rack */
        .rack-container {
            max-width: 800px;
            margin: 0 auto 30px;
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 40px var(--shadow);
        }

        .rack-title { text-align: center; color: var(--primary); font-weight: 700; margin-bottom: 12px; letter-spacing: 1px; text-transform: uppercase; font-size: 14px; }

        .rack { display: flex; justify-content: center; gap: 16px; }

        .slot {
            width: 80px; height: 100px;
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            border: 3px solid var(--border);
            border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s;
        }

        .slot:hover { transform: translateY(-4px); border-color: var(--primary); }
        
        .slot.held {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: var(--primary);
            transform: translateY(-8px);
        }
        .slot.held .slot-value { color: white; }
        .slot.held .slot-label { opacity: 1; color: white; }

        .slot-value { font-size: 36px; font-weight: 700; color: var(--text); }
        .slot-label { font-size: 10px; font-weight: 700; color: var(--primary); margin-top: 4px; opacity: 0; }

        /* Roll Area - CENTERED */
        .roll-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 40px;
        }

        .roll-counter { color: white; font-weight: 700; font-size: 18px; text-shadow: 0 2px 5px rgba(0,0,0,0.2); }

        /* Scorecard */
        .scorecard-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 24px;
            padding: 30px;
            box-shadow: 0 20px 60px var(--shadow);
            overflow-x: auto;
        }

        table { width: 100%; border-collapse: separate; border-spacing: 0; }
        th, td { padding: 16px; text-align: center; border-bottom: 2px solid var(--border); }
        th { font-weight: 700; font-size: 14px; }
        
        .col-cat { text-align: left; width: 200px; position: sticky; left: 0; background: white; z-index: 10; font-weight: 700; }
        .col-player { min-width: 140px; cursor: grab; }

        .player-header { border-radius: 12px; padding: 16px; color: white; position: relative; }
        .player-name-input { border: none; background: rgba(255,255,255,0.2); color: white; font-weight: 700; text-align: center; width: 100%; padding: 8px; border-radius: 8px; }
        .player-controls { display: flex; justify-content: center; gap: 8px; margin-top: 8px; }

        .score-input { width: 100%; border: none; text-align: center; font-size: 20px; font-weight: 700; outline: none; background: transparent; }
        .score-input:hover:not([readonly]) { background: rgba(102, 126, 234, 0.1); border-radius: 8px; }
        .score-suggestion { position: absolute; top: 4px; right: 4px; background: var(--success); color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; }
        
        .row-shaded td { background: linear-gradient(145deg, #f7fafc, #edf2f7); }
        .calculated-score { font-size: 22px; font-weight: 700; color: var(--primary); }

        /* Utilities */
        .color-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .color-modal.active { opacity: 1; pointer-events: all; }
        .color-modal-content { background: white; padding: 30px; border-radius: 20px; }
        .color-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-top: 20px; }
        .color-option { width: 60px; height: 60px; border-radius: 12px; cursor: pointer; transition: transform 0.2s; }
        .color-option:hover { transform: scale(1.1); }
        .info { display: inline-flex; width: 20px; height: 20px; background: var(--primary); color: white; border-radius: 50%; font-size: 12px; align-items: center; justify-content: center; cursor: help; margin-left: 8px; position: relative; }
        .tip { position: absolute; bottom: 130%; left: 50%; transform: translateX(-50%); background: #2d3748; color: white; padding: 12px; border-radius: 8px; width: max-content; opacity: 0; pointer-events: none; transition: opacity 0.2s; z-index: 100; }
        .info:hover .tip { opacity: 1; }
        
        @media (max-width: 768px) {
            .header h1 { font-size: 2rem; }
            .rack { gap: 8px; }
            .slot { width: 60px; height: 80px; }
        }
    </style>
</head>
<body data-theme="light">
    <div class="header">
        <h1>üé≤ Yahtzee Elite</h1>
        <div class="controls">
            <button class="btn" onclick="game.addPlayer()">üë§ Add Player</button>
            <button class="btn" onclick="game.toggleMode()" id="modeBtn">üìã Scorecard Only</button>
            <button class="btn" onclick="game.toggleTheme()">üåì Theme</button>
            <button class="btn" onclick="game.resetDice()">üé≤ New Turn</button>
            <button class="btn btn-danger" onclick="game.fullReset()">‚ôªÔ∏è Full Reset</button>
        </div>
    </div>

    <div id="gameArea">
        <div class="tray-container">
            <div id="tray"></div>
        </div>

        <div class="rack-container">
            <div class="rack-title">Lock Dice - Click to Hold</div>
            <div class="rack">
                <div class="slot" onclick="game.toggleHold(0)" id="slot-0">
                    <div class="slot-value" id="v-0">-</div>
                    <div class="slot-label">LOCKED</div>
                </div>
                <div class="slot" onclick="game.toggleHold(1)" id="slot-1">
                    <div class="slot-value" id="v-1">-</div>
                    <div class="slot-label">LOCKED</div>
                </div>
                <div class="slot" onclick="game.toggleHold(2)" id="slot-2">
                    <div class="slot-value" id="v-2">-</div>
                    <div class="slot-label">LOCKED</div>
                </div>
                <div class="slot" onclick="game.toggleHold(3)" id="slot-3">
                    <div class="slot-value" id="v-3">-</div>
                    <div class="slot-label">LOCKED</div>
                </div>
                <div class="slot" onclick="game.toggleHold(4)" id="slot-4">
                    <div class="slot-value" id="v-4">-</div>
                    <div class="slot-label">LOCKED</div>
                </div>
            </div>
        </div>

        <div class="roll-area">
            <button class="btn btn-primary" id="rollBtn" onclick="game.roll()">
                üé≤ ROLL DICE
            </button>
            <div class="roll-counter" id="rollCounter">ROLL 0 / 3</div>
        </div>
    </div>

    <div class="scorecard-container">
        <table id="scoreTable">
            <thead id="head"></thead>
            <tbody id="rows"></tbody>
        </table>
    </div>

    <div class="color-modal" id="colorModal" onclick="game.closeColorModal()">
        <div class="color-modal-content" onclick="event.stopPropagation()">
            <h3 style="text-align: center;">Choose Color</h3>
            <div class="color-grid" id="colorGrid"></div>
        </div>
    </div>

    <script>
        const COLORS = ['--c1', '--c2', '--c3', '--c4', '--c5', '--c6', '--c7', '--c8'];
        const RULES = [
            { id: '1s', name: 'Ones', tip: 'Sum of all 1s' },
            { id: '2s', name: 'Twos', tip: 'Sum of all 2s' },
            { id: '3s', name: 'Threes', tip: 'Sum of all 3s' },
            { id: '4s', name: 'Fours', tip: 'Sum of all 4s' },
            { id: '5s', name: 'Fives', tip: 'Sum of all 5s' },
            { id: '6s', name: 'Sixes', tip: 'Sum of all 6s' },
            { id: 'uSum', name: 'Upper Total', tip: 'Sum of upper section', shaded: true, calc: true },
            { id: 'bonus', name: 'Bonus (+35)', tip: '35 points if upper total ‚â• 63', shaded: true, calc: true },
            { id: 'tk', name: '3 of a Kind', tip: 'Sum of all dice if 3+ match' },
            { id: 'fk', name: '4 of a Kind', tip: 'Sum of all dice if 4+ match' },
            { id: 'fh', name: 'Full House', tip: '25 points for 3 + 2' },
            { id: 'ss', name: 'Small Straight', tip: '30 points for 4 in sequence' },
            { id: 'ls', name: 'Large Straight', tip: '40 points for 5 in sequence' },
            { id: 'yz', name: 'YAHTZEE', tip: '50 points for 5 of a kind' },
            { id: 'ch', name: 'Chance', tip: 'Sum of all dice' },
            { id: 'grand', name: 'üèÜ GRAND TOTAL', tip: 'Final score', shaded: true, calc: true }
        ];

        class YahtzeeElite {
            constructor() {
                this.players = [{ name: 'Player 1', color: '--c1', scores: {} }];
                this.dice = [0, 0, 0, 0, 0];
                this.held = [false, false, false, false, false];
                this.rolls = 0;
                this.isScorecardOnly = false;
                this.isRolling = false;
                this.engine = null;
                this.diceBodies = [];
                this.currentColorPickerPlayer = null;
                
                // Canvas vars
                this.canvas = null;
                this.ctx = null;
                this.width = 0;
                this.height = 0;

                this.init();
            }

            init() {
                this.setupPhysics();
                this.renderAll();
                this.setupColorPicker();
                this.setupKeyboardShortcuts();
            }

            setupPhysics() {
                const { Engine, World, Bodies, Runner } = Matter;
                
                // 1. Setup Canvas
                const tray = document.getElementById('tray');
                this.width = tray.clientWidth || 800; // Fallback
                this.height = tray.clientHeight || 400;

                this.canvas = document.createElement('canvas');
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                tray.innerHTML = ''; // Clear previous
                tray.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');

                // 2. Setup Matter JS Engine
                this.engine = Engine.create();
                
                // TOP DOWN PHYSICS SETTINGS
                this.engine.gravity.y = 0; // No falling
                this.engine.gravity.x = 0;

                // 3. Create Walls (Invisible) with HIGH FRICTION
                const wallOptions = { 
                    isStatic: true, 
                    restitution: 0.8, 
                    friction: 0.5 // High friction allows dice to spin off walls
                };
                
                const walls = [
                    Bodies.rectangle(this.width/2, -50, this.width, 100, wallOptions), // Top
                    Bodies.rectangle(this.width/2, this.height + 50, this.width, 100, wallOptions), // Bottom
                    Bodies.rectangle(-50, this.height/2, 100, this.height, wallOptions), // Left
                    Bodies.rectangle(this.width + 50, this.height/2, 100, this.height, wallOptions) // Right
                ];
                World.add(this.engine.world, walls);

                // 4. Custom Render Loop
                const animate = () => {
                    window.requestAnimationFrame(animate);
                    
                    // Step Physics
                    Engine.update(this.engine, 1000 / 60);

                    // Clear Canvas
                    this.ctx.clearRect(0, 0, this.width, this.height);

                    // Draw Dice
                    this.diceBodies.forEach(body => {
                        if (body) this.drawDie(this.ctx, body);
                    });
                };

                animate();
            }

            drawDie(ctx, body) {
                const size = 60;
                const radius = 10;
                const dotSize = 6;
                const speed = body.speed;
                const angularSpeed = Math.abs(body.angularVelocity);
                
                ctx.save();
                ctx.translate(body.position.x, body.position.y);
                ctx.rotate(body.angle);
                
                // Dynamic Shadow (Moves away when fast to simulate hopping)
                const shadowOffset = Math.min(10, 5 + speed * 1.5);
                ctx.shadowColor = "rgba(0,0,0,0.3)";
                ctx.shadowBlur = 10 + speed * 2;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = shadowOffset;

                // --- RENDERING STATES ---
                if (speed > 4) {
                    // STATE 1: HIGH SPEED BLUR
                    // Don't draw dots. Draw a motion blur effect.
                    ctx.fillStyle = "#ffffff";
                    
                    // Main body
                    this.drawRoundedRect(ctx, -size/2, -size/2, size, size, radius);
                    ctx.fill();

                    // Draw "blur lines" instead of dots to look like spinning face
                    ctx.strokeStyle = "#e2e8f0";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(-15, -15); ctx.lineTo(15, 15);
                    ctx.moveTo(15, -15); ctx.lineTo(-15, 15);
                    ctx.stroke();

                } else if (speed > 0.5) {
                    // STATE 2: TUMBLING
                    // Draw face, but scramble values rapidly
                    const tumbleVal = Math.floor(Math.random() * 6) + 1;
                    
                    ctx.fillStyle = "#ffffff";
                    this.drawRoundedRect(ctx, -size/2, -size/2, size, size, radius);
                    ctx.fill();

                    ctx.shadowColor = "transparent";
                    ctx.fillStyle = "rgba(45, 55, 72, 0.5)"; // Semi-transparent dots
                    this.drawDots(ctx, tumbleVal, size, dotSize);

                } else {
                    // STATE 3: SETTLED
                    // Crisp, clear drawing
                    ctx.fillStyle = "#ffffff";
                    this.drawRoundedRect(ctx, -size/2, -size/2, size, size, radius);
                    ctx.fill();

                    ctx.shadowColor = "transparent";
                    ctx.fillStyle = "#2d3748"; // Solid dots
                    this.drawDots(ctx, body.value, size, dotSize);
                }

                ctx.restore();
            }

            drawRoundedRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            drawDots(ctx, v, size, dotSize) {
                const q = size / 4;
                const drawDot = (dx, dy) => {
                    ctx.beginPath();
                    ctx.arc(dx, dy, dotSize, 0, Math.PI * 2);
                    ctx.fill();
                };

                if (v % 2 !== 0) drawDot(0, 0); // 1, 3, 5
                if (v > 1) { drawDot(-q, -q); drawDot(q, q); } // 2+
                if (v > 3) { drawDot(q, -q); drawDot(-q, q); } // 4+
                if (v === 6) { drawDot(-q, 0); drawDot(q, 0); } // 6
            }

            createDie(value, index) {
                const { Bodies } = Matter;
                const size = 60;
                
                // Center Spawn
                const startX = this.width / 2 + (Math.random() * 40 - 20);
                const startY = this.height / 2 + (Math.random() * 40 - 20);

                const die = Bodies.rectangle(startX, startY, size, size, {
                    restitution: 0.6, // Less bouncy, more solid
                    friction: 0.1,    // Grip the table!
                    frictionAir: 0.02, // Slide well but eventually stop
                    density: 0.002,
                    angle: Math.random() * Math.PI * 2,
                    value: value 
                });
                die.value = value;
                return die;
            }

            roll() {
                if (this.rolls >= 3 || this.isRolling || this.isScorecardOnly) return;
                
                this.playSound('roll');
                this.isRolling = true;
                this.rolls++;

                const { World } = Matter;
                
                // Clear old dice
                this.diceBodies.forEach((body, i) => {
                    if (body && !this.held[i]) {
                        World.remove(this.engine.world, body);
                        this.diceBodies[i] = null;
                    }
                });

                // Create and throw new dice
                this.dice = this.dice.map((v, i) => {
                    if (this.held[i]) return v;
                    
                    const newVal = Math.floor(Math.random() * 6) + 1;
                    const die = this.createDie(newVal, i);
                    World.add(this.engine.world, die);
                    this.diceBodies[i] = die;

                    // FORCE + SPIN
                    // Throw outward from center in random direction
                    const angle = Math.random() * Math.PI * 2;
                    const force = 0.04 + Math.random() * 0.02; // Stronger throw
                    
                    Matter.Body.applyForce(die, die.position, {
                        x: Math.cos(angle) * force,
                        y: Math.sin(angle) * force
                    });
                    
                    // High spin for tumble effect
                    Matter.Body.setAngularVelocity(die, (Math.random() - 0.5) * 1.0);

                    return newVal;
                });

                // Wait for settle
                setTimeout(() => {
                    this.isRolling = false;
                    this.updateRack();
                    document.getElementById('rollCounter').textContent = `ROLL ${this.rolls} / 3`;
                    if (this.rolls === 3) document.getElementById('rollBtn').disabled = true;
                }, 2000);
            }

            updateRack() {
                this.dice.forEach((v, i) => {
                    document.getElementById(`v-${i}`).textContent = v || '-';
                });
            }

            toggleHold(i) {
                if (this.rolls === 0 || this.isRolling) return;
                this.held[i] = !this.held[i];
                document.getElementById(`slot-${i}`).classList.toggle('held', this.held[i]);
                this.playSound('click');
            }

            // --- UI Rendering (Scorecard, etc) ---
            renderAll() { this.renderHeaders(); this.renderRows(); }

            renderHeaders() {
                const head = document.getElementById('head');
                let html = '<tr><th class="col-cat">Category</th>';
                this.players.forEach((p, i) => {
                    html += `
                        <th class="col-player" draggable="true" data-idx="${i}">
                            <div class="player-header" style="background: var(${p.color})">
                                <input class="player-name-input" value="${p.name}" 
                                    onchange="game.updatePlayerName(${i}, this.value)"
                                    placeholder="Player ${i + 1}">
                                <div class="player-controls">
                                    <div class="color-option" style="width:20px;height:20px;background:white;opacity:0.5" onclick="game.openColorPicker(${i})"></div>
                                    ${this.players.length > 1 ? `<span onclick="game.removePlayer(${i})" style="cursor:pointer;opacity:0.7">‚úï</span>` : ''}
                                </div>
                            </div>
                        </th>`;
                });
                head.innerHTML = html + '</tr>';
                this.setupDragAndDrop();
            }

            renderRows() {
                const tbody = document.getElementById('rows');
                tbody.innerHTML = '';
                RULES.forEach(rule => {
                    const tr = document.createElement('tr');
                    if (rule.shaded) tr.classList.add('row-shaded');
                    let html = `<td class="col-cat">${rule.name}<span class="info">?<div class="tip">${rule.tip}</div></span></td>`;
                    
                    this.players.forEach((p, pIdx) => {
                        const score = p.scores[rule.id];
                        if (rule.calc) {
                            html += `<td><div class="calculated-score">${this.calculate(pIdx, rule.id)}</div></td>`;
                        } else {
                            const suggestion = this.rolls > 0 && score === undefined ? this.calcLogic(rule.id) : null;
                            html += `<td><div class="score-cell">
                                <input class="score-input" type="number" value="${score ?? ''}" 
                                    ${this.isScorecardOnly ? '' : 'readonly'} ${score !== undefined ? 'disabled' : ''}
                                    onclick="${!this.isScorecardOnly ? `game.scoreMove(${pIdx}, '${rule.id}')` : ''}"
                                    onchange="game.manualEntry(${pIdx}, '${rule.id}', this.value)">
                                ${suggestion !== null ? `<div class="score-suggestion">+${suggestion}</div>` : ''}
                            </div></td>`;
                        }
                    });
                    tr.innerHTML = html;
                    tbody.appendChild(tr);
                });
            }

            // Logic Helpers
            calcLogic(id) {
                const d = this.dice.filter(x => x > 0);
                if (!d.length) return 0;
                const sum = d.reduce((a, b) => a + b, 0);
                const counts = {}; d.forEach(x => counts[x] = (counts[x] || 0) + 1);
                const unique = [...new Set(d)].sort((a,b) => a-b).join('');
                
                switch(id) {
                    case '1s': return (counts[1] || 0) * 1;
                    case '2s': return (counts[2] || 0) * 2;
                    case '3s': return (counts[3] || 0) * 3;
                    case '4s': return (counts[4] || 0) * 4;
                    case '5s': return (counts[5] || 0) * 5;
                    case '6s': return (counts[6] || 0) * 6;
                    case 'tk': return Object.values(counts).some(x => x >= 3) ? sum : 0;
                    case 'fk': return Object.values(counts).some(x => x >= 4) ? sum : 0;
                    case 'fh': return (Object.values(counts).includes(3) && Object.values(counts).includes(2)) || Object.values(counts).includes(5) ? 25 : 0;
                    case 'ss': return /1234|2345|3456/.test(unique) ? 30 : 0;
                    case 'ls': return /12345|23456/.test(unique) ? 40 : 0;
                    case 'yz': return Object.values(counts).includes(5) ? 50 : 0;
                    case 'ch': return sum;
                    default: return 0;
                }
            }

            calculate(pIdx, type) {
                const p = this.players[pIdx];
                const upper = ['1s','2s','3s','4s','5s','6s'].reduce((s, k) => s + (p.scores[k]||0), 0);
                if (type === 'uSum') return upper;
                if (type === 'bonus') return upper >= 63 ? 35 : 0;
                if (type === 'grand') return upper + (upper >= 63 ? 35 : 0) + 
                    ['tk','fk','fh','ss','ls','yz','ch'].reduce((s, k) => s + (p.scores[k]||0), 0);
            }

            // Game Management
            scoreMove(pIdx, id) {
                if (this.rolls === 0 || this.players[pIdx].scores[id] !== undefined) return;
                const score = this.calcLogic(id);
                this.players[pIdx].scores[id] = score;
                if (id === 'yz' && score === 50) this.playSound('yahtzee'); // Celebrate
                this.resetDice();
                this.renderAll();
                this.playSound('score');
            }

            resetDice() {
                this.rolls = 0;
                this.held.fill(false);
                this.dice.fill(0);
                this.diceBodies.forEach(b => { if(b) Matter.World.remove(this.engine.world, b); });
                this.diceBodies = [];
                document.getElementById('rollBtn').disabled = false;
                document.getElementById('rollCounter').textContent = 'ROLL 0 / 3';
                this.updateRack();
                document.querySelectorAll('.slot').forEach(s => s.classList.remove('held'));
            }

            manualEntry(pIdx, id, val) {
                const n = parseInt(val);
                if (isNaN(n) || n < 0) delete this.players[pIdx].scores[id];
                else this.players[pIdx].scores[id] = n;
                this.renderRows();
            }

            addPlayer() {
                if (this.players.length >= 8) return alert('Max 8 players');
                this.players.push({ name: `Player ${this.players.length+1}`, color: COLORS[this.players.length%8], scores: {} });
                this.renderAll();
            }
            removePlayer(idx) {
                if (this.players.length > 1 && confirm(`Remove player?`)) {
                    this.players.splice(idx, 1);
                    this.renderAll();
                }
            }

            // UI Helpers
            setupDragAndDrop() {
                const headers = document.querySelectorAll('.col-player');
                headers.forEach(h => {
                    h.addEventListener('dragstart', e => { e.dataTransfer.setData('text', h.dataset.idx); });
                    h.addEventListener('dragover', e => e.preventDefault());
                    h.addEventListener('drop', e => {
                        e.preventDefault();
                        const from = parseInt(e.dataTransfer.getData('text'));
                        const to = parseInt(h.dataset.idx);
                        if (from !== to) {
                            const p = this.players.splice(from, 1)[0];
                            this.players.splice(to, 0, p);
                            this.renderAll();
                        }
                    });
                });
            }
            setupColorPicker() {
                const grid = document.getElementById('colorGrid');
                COLORS.forEach(c => {
                    const el = document.createElement('div');
                    el.className = 'color-option';
                    el.style.background = `var(${c})`;
                    el.onclick = () => {
                        if (this.currentColorPickerPlayer !== null) {
                            this.players[this.currentColorPickerPlayer].color = c;
                            this.renderAll();
                            this.closeColorModal();
                        }
                    };
                    grid.appendChild(el);
                });
            }
            openColorPicker(i) { this.currentColorPickerPlayer = i; document.getElementById('colorModal').classList.add('active'); }
            closeColorModal() { document.getElementById('colorModal').classList.remove('active'); }
            toggleMode() {
                this.isScorecardOnly = !this.isScorecardOnly;
                document.getElementById('gameArea').style.display = this.isScorecardOnly ? 'none' : 'block';
                document.getElementById('modeBtn').textContent = this.isScorecardOnly ? 'üéÆ Enable Dice' : 'üìã Scorecard Only';
                this.renderRows();
            }
            toggleTheme() { document.body.dataset.theme = document.body.dataset.theme === 'dark' ? 'light' : 'dark'; }
            
            updatePlayerName(idx, val) { this.players[idx].name = val || `Player ${idx+1}`; }
            
            playSound(type) {
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.connect(g); g.connect(ctx.destination);
                    if (type === 'roll') { osc.frequency.value = 200; g.gain.value = 0.1; osc.start(); osc.stop(ctx.currentTime + 0.1); }
                    if (type === 'click') { osc.frequency.value = 800; g.gain.value = 0.05; osc.start(); osc.stop(ctx.currentTime + 0.05); }
                    if (type === 'score') { osc.frequency.value = 600; g.gain.value = 0.1; osc.start(); osc.stop(ctx.currentTime + 0.15); }
                } catch(e) {}
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', e => {
                    if (e.target.tagName === 'INPUT') return;
                    if (e.key === ' ' && !this.isScorecardOnly) { e.preventDefault(); this.roll(); }
                    if (e.key === 'r') this.resetDice();
                    if (['1','2','3','4','5'].includes(e.key)) this.toggleHold(parseInt(e.key)-1);
                });
            }
            
            fullReset() { if(confirm("Reset everything?")) { this.players.forEach(p => p.scores={}); this.resetDice(); this.renderAll(); } }
        }

        const game = new YahtzeeElite();
    </script>
</body>
</html>
