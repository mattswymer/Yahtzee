<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Yahtzee Elite 3D Pro | Beta Build</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700;800&display=swap');

        :root {
            --bg: #f8fafc;
            --surface: #ffffff;
            --surface-2: #f1f5f9;
            --text: #0f172a;
            --text-muted: #64748b;
            --primary: #6366f1;
            --primary-light: rgba(99, 102, 241, 0.1);
            --accent: #10b981;
            --danger: #ef4444;
            --border: #e2e8f0;
            --radius: 20px;
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.05);
            --tray-bg: #1e293b;
        }

        [data-theme="dark"] {
            --bg: #020617;
            --surface: #0f172a;
            --surface-2: #1e293b;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --border: #334155;
            --primary-light: rgba(99, 102, 241, 0.2);
            --tray-bg: #000000;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background: var(--bg);
            color: var(--text);
            transition: background 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-x: hidden;
            min-height: 100vh;
        }

        .app-shell {
            max-width: 1440px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 32px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.scorecard-focused .app-shell {
            grid-template-columns: 1fr;
            max-width: 900px;
        }

        header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .logo { font-weight: 800; font-size: 1.6rem; letter-spacing: -1px; display: flex; align-items: center; gap: 10px; }

        .toolbar { display: flex; gap: 12px; flex-wrap: wrap; }
        .btn {
            padding: 12px 20px;
            border-radius: 14px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            touch-action: manipulation;
        }
        .btn:hover { background: var(--surface-2); transform: translateY(-1px); border-color: var(--text-muted); }
        .btn-primary { background: var(--primary); color: white; border: none; }
        .btn-primary:hover { background: #4f46e5; box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none !important; }

        .main-stage { display: flex; flex-direction: column; gap: 24px; }
        body.scorecard-focused .main-stage { display: none; }

        .tray-viewport {
            width: 100%;
            aspect-ratio: 16 / 10;
            background: var(--tray-bg);
            border-radius: 28px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 30px 60px -12px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #canvas-3d {
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents scrolling while rolling on mobile */
        }

        .dice-controls {
            background: var(--surface);
            padding: 24px;
            border-radius: 28px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .rack { display: flex; gap: 16px; flex-wrap: wrap; justify-content: center; }
        .die-slot {
            width: 75px;
            height: 95px;
            background: var(--surface-2);
            border: 2px solid var(--border);
            border-radius: 18px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            touch-action: manipulation;
        }
        .die-slot.held {
            background: var(--primary);
            border-color: var(--primary);
            transform: translateY(-12px);
            box-shadow: 0 15px 30px rgba(99, 102, 241, 0.3);
        }
        .die-slot.held .val { color: white; }
        .die-slot.held .lbl { color: rgba(255,255,255,0.7); }
        .die-slot .val { font-size: 2rem; font-weight: 800; }
        .die-slot .lbl { font-size: 0.65rem; font-weight: 800; text-transform: uppercase; color: var(--text-muted); }

        .scorecard-container {
            background: var(--surface);
            border-radius: 28px;
            padding: 32px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .score-scroll { overflow-x: auto; margin: 0 -10px; padding: 10px; }

        table { width: 100%; border-collapse: separate; border-spacing: 0; }

        .active-turn-col { background: var(--primary-light) !important; }

        th, td { padding: 14px 10px; border-bottom: 1px solid var(--border); }
        th { text-align: left; font-size: 0.7rem; text-transform: uppercase; color: var(--text-muted); font-weight: 800; letter-spacing: 1px; }

        .player-header { min-width: 110px; text-align: center; cursor: grab; position: relative; }
        .player-name-input {
            width: 100%;
            background: transparent;
            border: none;
            text-align: center;
            font-family: inherit;
            font-weight: 800;
            color: var(--text);
            font-size: 1rem; /* 16px to prevent iOS zoom */
            outline: none;
            padding: 4px;
            border-radius: 6px;
        }
        .player-name-input:focus { background: var(--surface-2); }
        .remove-player {
            position: absolute;
            top: -8px;
            right: 2px;
            color: var(--danger);
            cursor: pointer;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .player-header:hover .remove-player { opacity: 1; }

        .cat-row:hover { background: var(--surface-2); }
        .cat-info { font-weight: 700; font-size: 0.9rem; cursor: help; display: flex; align-items: center; gap: 8px; }
        .cat-info .tip-icon { font-size: 0.65rem; color: var(--text-muted); border: 1.5px solid var(--border); border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; }

        .score-cell {
            text-align: center;
            font-weight: 800;
            cursor: pointer;
            height: 48px;
            transition: all 0.2s;
            border-radius: 10px;
        }
        .score-cell.locked { cursor: default; }
        .score-cell.hint { color: var(--accent); opacity: 0.5; font-size: 0.95rem; }
        .score-cell:hover:not(.locked) { background: rgba(16, 185, 129, 0.12); }

        .total-row { background: var(--surface-2); font-weight: 800; color: var(--primary); }

        .tooltip {
            position: absolute;
            background: #0f172a;
            color: white;
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 0.8rem;
            z-index: 1000;
            pointer-events: none;
            max-width: 220px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            display: none;
            line-height: 1.4;
        }

        @media (max-width: 1024px) {
            .app-shell { grid-template-columns: 1fr; padding: 16px; }
            .die-slot { width: 60px; height: 80px; }
            .die-slot .val { font-size: 1.5rem; }
        }

        @media (max-width: 600px) {
             .logo { font-size: 1.3rem; }
             .toolbar { gap: 8px; }
             .btn { padding: 10px 14px; font-size: 0.8rem; }
             .die-slot { width: 50px; height: 70px; }
        }
    </style>
</head>
<body>

<div class="app-shell">
    <header>
        <div class="logo"><span>ðŸŽ²</span> YAHTZEE ELITE PRO</div>
        <div class="toolbar">
            <button class="btn" onclick="game.toggleFocusMode()" id="focusBtn">ðŸ“‹ Scorecard Only</button>
            <button class="btn" onclick="game.undo()" id="undoBtn" disabled>â†© Undo</button>
            <button class="btn" onclick="game.toggleTheme()">ðŸŒ“ Theme</button>
            <button class="btn" style="color: var(--danger)" onclick="game.fullReset()">â™» Reset</button>
        </div>
    </header>

    <main class="main-stage">
        <div class="tray-viewport">
            <div id="canvas-3d"></div>
        </div>

        <div class="dice-controls">
            <div style="display: flex; justify-content: space-between; width: 100%; align-items: center; padding: 0 10px;">
                <span id="rollStatus" style="font-weight: 800; font-size: 0.85rem; text-transform: uppercase; color: var(--text-muted); letter-spacing: 1px;">Roll 0 / 3</span>
                <button class="btn" onclick="game.clearTray()">ðŸ”„ Clear Tray</button>
            </div>

            <div class="rack" id="diceRack">
                </div>

            <button class="btn btn-primary" id="rollBtn" onclick="game.roll()" style="padding: 18px 80px; font-size: 1.2rem; letter-spacing: 1px; width: 100%; max-width: 400px;">
                ROLL DICE
            </button>
        </div>
    </main>

    <aside class="scorecard-container">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <button class="btn" onclick="game.prevTurn()">â—€</button>
                <div style="text-align: center; min-width: 120px;">
                    <div style="font-size: 0.65rem; font-weight: 800; color: var(--text-muted); text-transform: uppercase;">Current Turn</div>
                    <h2 id="activePlayerDisplay" style="font-size: 1.1rem; font-weight: 800;">Player 1</h2>
                </div>
                <button class="btn" onclick="game.nextTurn()">â–¶</button>
            </div>
            <button class="btn btn-primary" onclick="game.addPlayer()">+ Player</button>
        </div>

        <div class="score-scroll">
            <table id="scoreTable">
                <thead>
                    <tr id="playerHeaderRow">
                        <th>Category</th>
                        </tr>
                </thead>
                <tbody id="scoreTableBody">
                    </tbody>
            </table>
        </div>
    </aside>
</div>

<div class="tooltip" id="globalTooltip"></div>

<script>
    /**
     * 3D PHYSICS ENGINE - OPTIMIZED & DYNAMIC BOUNDARIES
     */
    class DiceEngine {
        constructor(containerId, onSettle) {
            this.container = document.getElementById(containerId);
            this.onSettle = onSettle;
            this.dice = [];
            this.walls = {};
            this.isRolling = false;

            this.initScene();
            this.initPhysics();
            this.createDice();
            this.animate();

            // Initial boundary setup
            this.updateBoundaries();

            window.addEventListener('resize', () => this.resize());
        }

        initScene() {
            this.scene = new THREE.Scene();
            this.scene.background = null;

            // Camera setup
            this.camera = new THREE.PerspectiveCamera(35, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
            this.camera.position.set(0, 18, 0);
            this.camera.lookAt(0, 0, 0);

            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.container.appendChild(this.renderer.domElement);

            // Lighting
            this.scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 0.6);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            sun.shadow.camera.left = -15; sun.shadow.camera.right = 15;
            sun.shadow.camera.top = 15; sun.shadow.camera.bottom = -15;
            this.scene.add(sun);

            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            this.scene.add(floor);
        }

        initPhysics() {
            this.world = new CANNON.World();
            // Reduced gravity to make dice float a bit more
            this.world.gravity.set(0, -25, 0);

            // Floor body
            const ground = new CANNON.Body({ mass: 0 });
            ground.addShape(new CANNON.Plane());
            ground.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            this.world.addBody(ground);

            // Create wall bodies (initially at 0, updated by updateBoundaries)
            const wallMat = new CANNON.Material();
            this.walls.top = this.createWallBody(wallMat);
            this.walls.bottom = this.createWallBody(wallMat);
            this.walls.left = this.createWallBody(wallMat);
            this.walls.right = this.createWallBody(wallMat);
        }

        createWallBody(mat) {
            const body = new CANNON.Body({ mass: 0, material: mat });
            this.world.addBody(body);
            return body;
        }

        updateBoundaries() {
            if (!this.container.clientHeight) return;

            // Calculate visible area at y=0 based on camera properties
            const dist = this.camera.position.y;
            const vFOV = THREE.Math.degToRad(this.camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            const visibleWidth = visibleHeight * (this.container.clientWidth / this.container.clientHeight);

            const w = visibleWidth / 2;
            const h = visibleHeight / 2;

            // Wall thickness
            const t = 1;

            // Update Top Wall
            this.walls.top.shapes = [];
            this.walls.top.addShape(new CANNON.Box(new CANNON.Vec3(visibleWidth, 20, t)));
            this.walls.top.position.set(0, 10, -h - t);

            // Update Bottom Wall
            this.walls.bottom.shapes = [];
            this.walls.bottom.addShape(new CANNON.Box(new CANNON.Vec3(visibleWidth, 20, t)));
            this.walls.bottom.position.set(0, 10, h + t);

            // Update Left Wall
            this.walls.left.shapes = [];
            this.walls.left.addShape(new CANNON.Box(new CANNON.Vec3(t, 20, visibleHeight)));
            this.walls.left.position.set(-w - t, 10, 0);

            // Update Right Wall
            this.walls.right.shapes = [];
            this.walls.right.addShape(new CANNON.Box(new CANNON.Vec3(t, 20, visibleHeight)));
            this.walls.right.position.set(w + t, 10, 0);
        }

        createDice() {
            const geo = new THREE.BoxGeometry(1.2, 1.2, 1.2, 3, 3, 3);
            const mats = this.getDiceMaterials();

            for(let i=0; i<5; i++) {
                const mesh = new THREE.Mesh(geo, mats);
                mesh.castShadow = true;

                const body = new CANNON.Body({
                    mass: 1.2,
                    shape: new CANNON.Box(new CANNON.Vec3(0.6, 0.6, 0.6)),
                    linearDamping: 0.01,  // Very low damping so they slide
                    angularDamping: 0.01   // Very low damping so they spin
                });
                body.position.set((i-2)*1.8, 1.5, 0);

                this.dice.push({ mesh, body });
                this.scene.add(mesh);
                this.world.addBody(body);
            }
        }

        getDiceMaterials() {
            const createFace = (n) => {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.beginPath(); ctx.roundRect(0, 0, 256, 256, 40); ctx.fill();
                ctx.fillStyle = '#1e293b';
                const dot = (x, y) => { ctx.beginPath(); ctx.arc(x, y, 22, 0, Math.PI*2); ctx.fill(); };
                if (n === 1) dot(128,128);
                if (n === 2) { dot(64,64); dot(192,192); }
                if (n === 3) { dot(64,64); dot(128,128); dot(192,192); }
                if (n === 4) { dot(64,64); dot(192,64); dot(64,192); dot(192,192); }
                if (n === 5) { dot(64,64); dot(192,64); dot(64,192); dot(192,192); dot(128,128); }
                if (n === 6) { dot(64,64); dot(64,128); dot(64,192); dot(192,64); dot(192,128); dot(192,192); }
                return new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(canvas), roughness: 0.3 });
            };
            return [1, 6, 2, 5, 3, 4].map(v => createFace(v));
        }

        roll(heldIndices) {
            this.isRolling = true;
            this.dice.forEach((d, i) => {
                if (heldIndices.includes(i)) return;

                // Random starting position slightly above
                d.body.position.set(Math.random()*2-1, 8 + i, Math.random()*2-1);

                // Add some upward velocity (y: 5) to give them an arc, plus random spread
                d.body.velocity.set(Math.random()*15-7.5, 5, Math.random()*15-7.5);

                d.body.angularVelocity.set(Math.random()*30, Math.random()*30, Math.random()*30);
                d.body.allowSleep = true;
            });
        }

        resetPhysics() {
            this.dice.forEach((d, i) => {
                d.body.position.set((i-2)*1.8, 1.5, 0);
                d.body.velocity.set(0,0,0);
                d.body.angularVelocity.set(0,0,0);
                d.body.quaternion.set(0,0,0,1);
            });
        }

        getValues() {
            const ups = [
                { v: 1, d: new THREE.Vector3(1,0,0) }, { v: 6, d: new THREE.Vector3(-1,0,0) },
                { v: 2, d: new THREE.Vector3(0,1,0) }, { v: 5, d: new THREE.Vector3(0,-1,0) },
                { v: 3, d: new THREE.Vector3(0,0,1) }, { v: 4, d: new THREE.Vector3(0,0,-1) }
            ];
            return this.dice.map(d => {
                let max = -1, val = 1;
                ups.forEach(u => {
                    const world = u.d.clone().applyQuaternion(d.mesh.quaternion);
                    if (world.y > max) { max = world.y; val = u.v; }
                });
                return val;
            });
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            this.world.step(1/60);
            let moving = false;
            this.dice.forEach(d => {
                d.mesh.position.copy(d.body.position);
                d.mesh.quaternion.copy(d.body.quaternion);
                if (d.body.velocity.length() > 0.1) moving = true;
            });
            if (this.isRolling && !moving) {
                this.isRolling = false;
                this.onSettle(this.getValues());
            }
            this.renderer.render(this.scene, this.camera);
        }

        resize() {
            if (!this.container.clientWidth) return;
            this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            this.updateBoundaries();
        }
    }

    /**
     * GAME ENGINE - CORE LOGIC
     */
    const RULES = [
        { id: '1s', name: 'Ones', tip: 'Total of all ones' },
        { id: '2s', name: 'Twos', tip: 'Total of all twos' },
        { id: '3s', name: 'Threes', tip: 'Total of all threes' },
        { id: '4s', name: 'Fours', tip: 'Total of all fours' },
        { id: '5s', name: 'Fives', tip: 'Total of all fives' },
        { id: '6s', name: 'Sixes', tip: 'Total of all sixes' },
        { id: 'uSum', name: 'Upper Total', calc: true },
        { id: 'bonus', name: 'Bonus (+35)', calc: true },
        { id: '3k', name: '3 of a Kind', tip: 'Sum of all dice if 3 match' },
        { id: '4k', name: '4 of a Kind', tip: 'Sum of all dice if 4 match' },
        { id: 'fh', name: 'Full House', tip: '25 points for 3 of a kind + pair' },
        { id: 'ss', name: 'Small Straight', tip: '30 points for sequence of 4' },
        { id: 'ls', name: 'Large Straight', tip: '40 points for sequence of 5' },
        { id: 'yz', name: 'Yahtzee', tip: '50 points for 5 of a kind' },
        { id: 'ch', name: 'Chance', tip: 'Sum of all dice' },
        { id: 'grand', name: 'Grand Total', calc: true }
    ];

    class YahtzeeElite {
        constructor() {
            this.players = [{ name: 'Player 1', scores: {} }];
            this.turnIdx = 0;
            this.rolls = 0;
            this.held = [];
            this.values = [1, 1, 1, 1, 1];
            this.history = [];

            this.engine = new DiceEngine('canvas-3d', (v) => this.onDiceSettle(v));
            this.initUI();
            this.render();
            this.setupTooltips();
        }

        initUI() {
            const rack = document.getElementById('diceRack');
            for(let i=0; i<5; i++) {
                const slot = document.createElement('div');
                slot.className = 'die-slot';
                slot.id = `slot-${i}`;
                slot.onclick = () => this.toggleHold(i);
                slot.innerHTML = `<span class="val" id="dv-${i}">-</span><span class="lbl">Hold</span>`;
                rack.appendChild(slot);
            }
        }

        setupTooltips() {
            const tt = document.getElementById('globalTooltip');
            document.body.addEventListener('mouseover', (e) => {
                const info = e.target.closest('.cat-info');
                if (info && info.dataset.tip) {
                    tt.textContent = info.dataset.tip;
                    tt.style.display = 'block';
                    tt.style.left = (e.pageX + 12) + 'px';
                    tt.style.top = (e.pageY + 12) + 'px';
                }
            });
            document.body.addEventListener('mouseout', () => tt.style.display = 'none');
        }

        roll() {
            if (this.rolls >= 3 || this.engine.isRolling) return;
            this.rolls++;
            this.engine.roll(this.held);
            this.updateStatus();
        }

        onDiceSettle(vals) {
            this.values = vals;
            vals.forEach((v, i) => document.getElementById(`dv-${i}`).textContent = v);
            this.updateStatus();
            this.render();
        }

        toggleHold(i) {
            if (this.rolls === 0 || this.engine.isRolling) return;
            const idx = this.held.indexOf(i);
            if (idx > -1) this.held.splice(idx, 1);
            else this.held.push(i);
            document.getElementById(`slot-${i}`).classList.toggle('held', this.held.includes(i));
        }

        clearTray() {
            this.rolls = 0; // RESET ROLLS TO MAKE DICE ROLLABLE AGAIN
            this.held = [];
            this.values = [1,1,1,1,1];
            document.querySelectorAll('.die-slot').forEach(s => s.classList.remove('held'));
            document.querySelectorAll('.val').forEach(v => v.textContent = '-');
            this.engine.resetPhysics();
            this.updateStatus();
            this.render();
        }

        score(pIdx, catId) {
            // MANUAL SCORE ENTRY MODE
            if (document.body.classList.contains('scorecard-focused')) {
                const current = this.players[pIdx].scores[catId];
                const rule = RULES.find(r => r.id === catId);
                const input = prompt(`Enter score for ${rule.name}:`, current !== undefined ? current : '');

                if (input === null) return; // Cancelled

                const val = parseInt(input);
                if (!isNaN(val)) {
                     this.players[pIdx].scores[catId] = val;
                     this.render();
                }
                return;
            }

            // STANDARD GAMEPLAY MODE
            if (pIdx !== this.turnIdx || this.rolls === 0 || this.players[pIdx].scores[catId] !== undefined) return;
            this.history.push(JSON.stringify({ players: this.players, turn: this.turnIdx }));
            document.getElementById('undoBtn').disabled = false;
            this.players[pIdx].scores[catId] = this.calcValue(catId, this.values);
            this.nextTurn();
        }

        calcValue(id, dice) {
            const sum = dice.reduce((a, b) => a + b, 0);
            const counts = {}; dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
            const unique = [...new Set(dice)].sort((a,b)=>a-b).join('');
            switch(id) {
                case '1s': return (counts[1] || 0) * 1;
                case '2s': return (counts[2] || 0) * 2;
                case '3s': return (counts[3] || 0) * 3;
                case '4s': return (counts[4] || 0) * 4;
                case '5s': return (counts[5] || 0) * 5;
                case '6s': return (counts[6] || 0) * 6;
                case '3k': return Object.values(counts).some(c => c >= 3) ? sum : 0;
                case '4k': return Object.values(counts).some(c => c >= 4) ? sum : 0;
                case 'fh': return Object.values(counts).includes(3) && Object.values(counts).includes(2) ? 25 : 0;
                case 'ss': return /1234|2345|3456/.test(unique) ? 30 : 0;
                case 'ls': return /12345|23456/.test(unique) ? 40 : 0;
                case 'yz': return Object.values(counts).includes(5) ? 50 : 0;
                case 'ch': return sum;
                default: return 0;
            }
        }

        nextTurn() {
            this.rolls = 0;
            this.held = [];
            this.turnIdx = (this.turnIdx + 1) % this.players.length;
            this.clearTray();
            this.render();
        }

        prevTurn() { this.turnIdx = (this.turnIdx - 1 + this.players.length) % this.players.length; this.render(); }

        updateStatus() {
            const btn = document.getElementById('rollBtn');
            btn.disabled = this.rolls >= 3 || this.engine.isRolling;
            document.getElementById('rollStatus').textContent = `Roll ${this.rolls} / 3`;
        }

        render() {
            const pHeader = document.getElementById('playerHeaderRow');
            pHeader.innerHTML = '<th>Category</th>' + this.players.map((p, i) => `
                <th class="player-header ${i === this.turnIdx ? 'active-turn-col' : ''}"
                    draggable="true" ondragstart="game.drag(${i})" ondragover="event.preventDefault()" ondrop="game.drop(${i})">
                    <span class="remove-player" onclick="game.removePlayer(${i})">âœ•</span>
                    <input class="player-name-input" value="${p.name}" onchange="game.renamePlayer(${i}, this.value)" onclick="this.select()">
                </th>`).join('');

            const body = document.getElementById('scoreTableBody');
            body.innerHTML = '';

            RULES.forEach(rule => {
                const tr = document.createElement('tr');
                tr.className = rule.calc ? 'total-row' : 'cat-row';
                let html = `<td class="cat-info" data-tip="${rule.tip || ''}">${rule.name} ${rule.tip ? '<span class="tip-icon">?</span>' : ''}</td>`;
                this.players.forEach((p, pi) => {
                    const val = p.scores[rule.id];
                    if (rule.calc) {
                        html += `<td class="score-cell locked ${pi === this.turnIdx ? 'active-turn-col' : ''}">${this.getCalcScore(pi, rule.id)}</td>`;
                    } else {
                        const isHint = pi === this.turnIdx && this.rolls > 0 && val === undefined;
                        const display = val !== undefined ? val : (isHint ? this.calcValue(rule.id, this.values) : '');
                        html += `<td class="score-cell ${val !== undefined ? 'locked' : ''} ${isHint ? 'hint' : ''} ${pi === this.turnIdx ? 'active-turn-col' : ''}"
                                     onclick="game.score(${pi}, '${rule.id}')">${display}</td>`;
                    }
                });
                tr.innerHTML = html; body.appendChild(tr);
            });
            document.getElementById('activePlayerDisplay').textContent = this.players[this.turnIdx].name;
        }

        getCalcScore(pi, id) {
            const p = this.players[pi];
            const u = ['1s','2s','3s','4s','5s','6s'].reduce((a,c) => a + (p.scores[c]||0), 0);
            if (id === 'uSum') return u;
            if (id === 'bonus') return u >= 63 ? 35 : 0;
            const l = ['3k','4k','fh','ss','ls','yz','ch'].reduce((a,c) => a + (p.scores[c]||0), 0);
            if (id === 'grand') return u + (u >= 63 ? 35 : 0) + l;
        }

        undo() {
            if (this.history.length === 0) return;
            const state = JSON.parse(this.history.pop());
            this.players = state.players; this.turnIdx = state.turn;
            if (this.history.length === 0) document.getElementById('undoBtn').disabled = true;
            this.render();
        }

        renamePlayer(i, val) { this.players[i].name = val || `Player ${i+1}`; this.render(); }
        addPlayer() { if(this.players.length < 8) this.players.push({ name: `Player ${this.players.length+1}`, scores: {} }); this.render(); }
        removePlayer(i) { if(this.players.length > 1) { this.players.splice(i, 1); this.turnIdx %= this.players.length; this.render(); } }
        drag(i) { this.dragIdx = i; }
        drop(i) { const p = this.players.splice(this.dragIdx, 1)[0]; this.players.splice(i, 0, p); this.render(); }

        toggleFocusMode() {
            document.body.classList.toggle('scorecard-focused');
            document.getElementById('focusBtn').textContent = document.body.classList.contains('scorecard-focused') ? 'ðŸŽ® Game Mode' : 'ðŸ“‹ Scorecard Only';

            // Wait for transition to end before resizing canvas
            setTimeout(() => {
                this.engine.resize();
            }, 550); // slightly longer than CSS transition 0.5s
        }

        toggleTheme() { document.body.dataset.theme = document.body.dataset.theme === 'dark' ? 'light' : 'dark'; }
        fullReset() { if(confirm("Clear all game data and restart?")) location.reload(); }
    }

    const game = new YahtzeeElite();
</script>

</body>
</html>